LOAD CSV WITH HEADERS FROM "file:///nodes_to_graph_id.csv" AS csvLine1
MERGE (u:User
 { 
    node_id: coalesce(csvLine1.user_node_id, "No user_node_id"),
    graph_id: coalesce(csvLine1.graph_id, "No graph_id"),
    label: coalesce(csvLine1.label, "No label"),
 }
);

LOAD CSV WITH HEADERS FROM "file:///edges.csv" AS csvLine2
MATCH (u1:User { node_id: csvLine2.from })
MATCH (u2:User { node_id: csvLine2.to })
MERGE (u1)-[:retweeted_post_of]->(u2)

// verify datasets, mean should be like in GNN-fake-news-detection on github

// create graph projection
CALL gds.graph.project('retweet_network','User','retweeted_post_of');

CALL gds.wcc.stats('retweet_network')
YIELD componentCount, componentDistribution
RETURN componentCount, 
       componentDistribution.min as min,
       componentDistribution.max as max,
       componentDistribution.mean as mean


// How many users with more than 1 relation

MATCH (u:User)
WHERE size((u)-[:retweeted_post_of]-()) > 1
RETURN u

// compute betweenness for true labeled nodes

// CALL gds.betweenness.stream('retweet_network')
// YIELD nodeId, score
// MATCH (user: User { label: "1.0"} ) WHERE id(user) = nodeId
// RETURN user.node_id, score
// ORDER BY score DESC

// export betweenness correlation data

CALL apoc.export.csv.query("
CALL gds.betweenness.stream('retweet_network')
YIELD nodeId, score
MATCH (user: User) WHERE id(user) = nodeId
RETURN nodeId, user.label, score
ORDER BY nodeId ASC", 'betweenness_correlation_data.csv', {});

// export closeness correlation data Wasserman and Faust

CALL apoc.export.csv.query("
CALL gds.beta.closeness.stream('retweet_network', {useWassermanFaust: true})
YIELD nodeId, score
MATCH (user: User) WHERE id(user) = nodeId
RETURN nodeId, user.label, score
ORDER BY nodeId ASC", 'closeness_correlation_data.csv', {})

// export harmonic closeness

CALL apoc.export.csv.query("
CALL gds.alpha.closeness.harmonic.stream('retweet_network')
YIELD nodeId, centrality
MATCH (user: User) WHERE id(user) = nodeId
RETURN nodeId, user.label, centrality
ORDER BY nodeId ASC", 'harmonic_closeness_correlation_data.csv', {})

// export degree correlation data

CALL apoc.export.csv.query("MATCH (u:User)
WITH id(u) as nodeId, size((u)-[:retweeted_post_of]->()) as outDegree, size((u)<-[:retweeted_post_of]-()) as inDegree
MATCH (u: User) WHERE id(u) = nodeId
RETURN nodeId, u.label, outDegree, inDegree, inDegree + outDegree as degree
ORDER BY nodeId ASC", 'degree_correlation_data.csv', {})

// PageRank
CALL apoc.export.csv.query("CALL gds.pageRank.stream('retweet_network', {maxIterations: 20, dampingFactor: 0.85})
YIELD nodeId, score
MATCH (user: User) WHERE id(user) = nodeId
RETURN nodeId, user.label, score
ORDER BY nodeId ASC", 'page_rank_correlation_data.csv', {})

// ArticleRank
CALL apoc.export.csv.query("CALL gds.articleRank.stream('retweet_network', {maxIterations: 20, dampingFactor: 0.85})
YIELD nodeId, score
MATCH (user: User) WHERE id(user) = nodeId
RETURN nodeId, user.label, score
ORDER BY nodeId ASC", 'page_rank_correlation_data.csv', {})


// Eigenvector
CALL apoc.export.csv.query("CALL gds.eigenvector.stream('retweet_network', {maxIterations: 40})
YIELD nodeId, score
MATCH (user: User) WHERE id(user) = nodeId
RETURN nodeId, user.label, score
ORDER BY nodeId ASC", 'eigenvector_correlation_data.csv', {})

// HITS
CALL apoc.export.csv.query("CALL gds.alpha.hits.stream('retweet_network', {hitsIterations: 50})
YIELD nodeId, values
MATCH (user: User) WHERE id(user) = nodeId
RETURN nodeId, user.label, values.hub, values.auth
ORDER BY nodeId ASC", 'hits_correlation_data.csv', {})